ACCOUNT_POSTING_RULES contains parameterage account trade rules
BO_CASH_WORKFLOW_DEF contains parameterage (Securities Workflow Definition)
BO_CASH_WORKFLOW (ID = h.WORKFLOW_ID)
BO_DEAL_WORKFLOW_SELECTOR
BO_KERNEL_WORKFLOW (ID = h.WORKFLOW_ID)
BO_KERNEL_WORKFLOW_DEF (WORKFLOW_ID = h.WORKFLOW_ID)
select * from BO_KERNEL_WORKFLOW_DEF where workflow_id = 36447726 and event_id = 270
CDC_BO_CODE_PRODUIT c (c.famille = 1 --> 'Ferme' else 'P/E', AllotmentTools::GetAllotmentFamilyId(affectation) == AllotmentTools::FERME)
CDC_FAMILLE_AFFECTATION (famille)
NATIXIS_FOLIO_SECTION_ENTITE fse (fse.Section = SECTION)
titres t (t.j1refcon2 = ploanAndRepo->GetPaymentType() = Frequency of contract (2= Mensuel, 1 = In Fine), MNEMO = ISIN, modele = GetModelName(), nbTitres = GetInstrumentCount())
histomvts h (refcon = h.GetTransactionCode, DEVISE_TO_STR(H.DEVISEPAY) CURRENCY (GetSettlementCurrency), h.GetPaymentMethod = PAYMENT_METHOD,
  h.GetDeliveryType = DELIVERY_TYPE (eBODeliveryType), h.GetSettlementMethod = WORKFLOW_ID, h.GetCreationKind = Creation
  h.refmvtback = mvtident (patte cash ou patte collat), h.reference = refcon (patte cash ou patte collat)
  h.GetNetAmount = Montant)
PAYMENTMETHOD pm (pm.ident = h.GetPaymentMethod)
mvt_auto (generated by forcast --> histomvts by ticket auto)
business_events be (h.GetTransactionType(), be.compta = 1 générant le compta)
bo_kernel_status ks
bo_kernel_status_component ksc (ksc.KERNEL_STATUS_GROUP_ID = ksg.ID)
BO_KERNEL_STATUS_GROUP ksg
affectation a (allotment, t->GetAllotment() = t.affectation)
tiers cp (AUDIT_TIERS_COMPO
    function ISACOUNTERPARTY determine if a tiers is contrepartie
    ESTDEPOSITAIRE(cp.option) determine if a tiers is depositaire)
tiersproperties tp (tp.code = cp.ident)
tierssettlement ts (ts.code = cp.ident, ACCOUNT_TYPE = 2 type instrument. 3 = type cash, ts.PLACE_OF_SETTLEMENT = tiers.ident
    ts.PAYMENT = PAYMENTMETHOD.IDENT, CUSTODIAN = TS.SWIFTCODE, ACCOUNT@CUSTODIAN = BANKNUM, AGENT_CODE = TS.ROUTING,
    ACCOUNT@AGENT = ACCOUNT_ROUTER)
AUDIT_TIERSSETTLEMENT, AUDIT_TIERS_COMPO
bo_messages bo (generation_date, doc_id, grp_code = 1 paiement, = 2 confirmation)
SENDINGMETHOD sm (sm.ident = bo.sending_method)
AUDIT_BO_MESSAGES abo (sm.ident = abo.sending_method)
update cdc_bo_clearvision set status='Ready' WHERE ident=6917921 --> resend a message to clear vision
select ident from NATIXIS_BO_PAS_FORWARD where status = 'P' --> update to P to resend message to PasForward

select BS.ID, BS.NAME, AM.* from AUDIT_BO_MESSAGES AM
join BO_EXTERNAL_STATUS BS ON BS.ID = AM.STATUS
where AM.ident = 6935438
order by audit_version

OTC_EVENTS (events retour de ASPA --> PasReturn)

AUDIT_BO_MESSAGES
BO_EXTERNAL_STATUS (status de BO_MESSAGES)
template te (te.ident = bo.template_id)
value_template vt (vt.ident = bo.doc_id)
account_posting (posting généré)
cma_rpt_operations op (op.mvttype = 0 commission, 1 cash, 2 repo, 3 cash pool)
cma_rpt_explanations ex
bo_pe_perimeter_def pd (pd.ID = T.PERIMETERID, pd.Name = Agreeement, Convention)
bo_pe_agreement_main am (am.entity_id = h.entite, am.ctpy_id = cp.ident = h.contrepartie, am.perimeter_id = t.perimeterid)
bo_pe_agreement_call ac (AC.PERIMETER_ID = AM.PERIMETER_ID)
bo_messages bo
audit_mvt ad (version, userid, datemodif, refcon, sicovam)
DmHistorique (cours historiques)
bo_kernel_events (name in ('BO modify Cash', 'BO refuse', 'FO modify'))
NATIXIS_PRIMARY_FOLIO
MIRRORMVTS (MVT_ID = REFCON de la patte FILS d’un miroir, REFERENCE = REFCON de la patte PERE d’un miroir)
SMDT = SetPaymentMethod, SetDeliveryType, SetSettlementMethod (workflow_id, delivery_type, PAYMENT_METHOD)
NATIXIS_GROUP_PARAM (checkdeals)
ecn_pltfm (name = h.ecn)
SINGLESIGNON (single sign on)                        

h.backoffice (status) (h.GetBackOfficeType())
h.mvtident = position ID (h.GetPositionID)
h.type = be.id
h.sicovam = t.sicovam
c.affectation = t.affectation
h.backoffice = ksc.kernel_status_id = ks.id
h.contrepartie = cp.ident (ContrePartie)
h.DEPOSITAIRE = cp.ident (DEPOSITAIRE)
h.entite = cp.ident (Entite)
folio.ident
h.opcvm = folio code (h.GetFolioCode) = fse.ident
ex.op_id = op.op_id

Fonctionnel:
Sophis --> refcon --> BO Accept --> Compta (Account_Posting)
Sophis --> refcon --> BO Accept --> Paiement, Confirmation
(Bo_Messages : status = 2 Hold, status = 21 Accepted, status = 3 ready. grp_code = 1 paiement, 2 confirmation,
  netting_type=0 pas encore netté, 1 netté, trade_id = null -> paiement d'un netting)
  IN THE PIPE --> IN PROGRESS (sent to ASCONF) --> REFUSED
  IN THE PIPE --> REFUSED (not sent to ASCONF)
  confirmation --> ConfDispatcher --> tables pool --> PretEmprunt --> ASPA
  paiement --> CosNotify --> PasForward --> ASPA --> Alteore (GRP-DSI-FCC-PARC-ALTEORE)
        ASPA --> PasReturn (102 IN PROGRESS)
        Alteore --> ASPA --> PasReturn (106 ACCEPTED)
refcon: CONTROLED --> VERIFIED --> Instruction generated by BOWS
BOWS --> refcon --> Instruction --> Instruction (bo_cash_instruction) message swift marché organisé
    sVER --> Ack swift
KERNEL(HISTOMVTS), SECURITIES (BO_CASH_INSTRUCTION)

Procedure de test:
1. Load Portfolio, new folder --> Ctrl + Alt + N --> selectionner contrepartie, Principal Ref (Sicovam)
2. Search SSI: Data\Third Parties\Settlement Instruction --> Copy all to excel
    --> filter by date to (31/12/2099), Account Type, Depositary = Sicovam, *   
3. New Deal
    - Reference, Entity, Contreparty, Quantity -> New Deal Accept  

SQL:
select * from folio connect by prior ident = mgr start with ident = 263529; // OPCVM de la position
select * from folio where ident = 43720;
DBMS_OUTPUT.put_line ('--' || worktable_name ||' IS NOT EMPTY');
select max(dtgen) FROM cdc_bo_crecri;
dot not do fullscan on audit_mvt
do not build a IN clause with null value (always use 'is not null')
do not use num_to_date(0), use TO_DATE('19040101', 'YYYYMMDD')
all instruction is in bo_cash_*
AUDIT_BO_CASH_INSTRUCTION
BO_CASH_INSTRUCTION
status BO_CASH_STATUS
not in simulation portfeuille:
  H.OPCVM not in ( 
          SELECT ident FROM FOLIO START WITH ident=43338 
          CONNECT BY PRIOR ident=mgr);
select a.version, a.userid, u.name, a.datemodif, a.refcon, a.sicovam, a.*
  from audit_mvt a
  left join riskusers u on u.ident = a.userid -- null if deleted
  where refcon = 150262737
  order by a.datemodif 
create table as select
CREATE GLOBAL TEMPORARY TABLE my_temp_table ON COMMIT PRESERVE ROWS as
CREATE GLOBAL TEMPORARY TABLE my_temp_table ON COMMIT DELETE ROWS as
insert all
  into BO_TEMP_ListContreparties values (10001086,'ABN AMRO BANK N.V AMSTERDAM')
  select * from dual
doublon:
  select  refcon, version, count(version)
  from audit_mvt where refcon in (select trade_id 
  from bo_cash_instruction where generation_date>= to_date ('20110401','YYYYMMDD') and generation_date< to_date ('20110530','YYYYMMDD') )
  group by refcon, version
  HAVING   COUNT (version) > 1;
real last modif:
  select a1.refcon,
      nvl2(a2.refcon, a2.backoffice, h.backoffice) backoffice,
      BO.NAME backoffice_name,
      A1.USERID, U.NAME, a1.datemodif,
      nvl2(a2.refcon, A2.DATEVAL, H.DATEVAL) DATEVAL,
      nvl2(a2.refcon, A2.DATENEG, H.DATENEG) DATENEG,
      nvl2(a2.refcon, A2.type, H.type) type,
      BE.NAME,
      nvl2(a2.refcon, A2.mvtident, H.mvtident) mvtident,
      UO.NAME operateur,
      nvl2(a2.refcon, A2.QUANTITE, H.QUANTITE) quantite,
      nvl2(a2.refcon, A2.MONTANT, H.MONTANT) montant,
      nvl2(a2.refcon, A2.MIRROR_REFERENCE, H.MIRROR_REFERENCE) MIRROR_REFERENCE,
      a1.version, 
      nvl2(a2.refcon, A2.INFOS, H.INFOS) INFOS,
      nvl2(a2.refcon, A2.COMMISSION_DATE, H.COMMISSION_DATE) COMMISSION_DATE,
      nvl2(a2.refcon, A2.delivery_date, H.delivery_date) delivery_date,
      nvl2(a2.refcon, A2.reference, H.reference) reference,
      nvl2(a2.refcon, A2.refmvtback, H.refmvtback) refmvtback
  from audit_mvt a1
      left join riskusers u on u.ident = a1.userid -- null if deleted
      left join audit_mvt a2 on a1.version + 1 = a2.version and a1.refcon = a2.refcon
      left join histomvts h on a1.refcon = h.refcon and a2.refcon is null
      left join RISKUSERS UO on UO.IDENT = nvl2(a2.refcon, A2.OPERATEUR, h.OPERATEUR)                         
      left join bo_kernel_status bo on BO.ID = nvl2(a2.refcon, a2.backoffice, h.backoffice)
      left join BUSINESS_EVENTS be on BE.ID = nvl2(a2.refcon, A2.type, H.type)
  where a1.refcon = 259901338 
  order by version
Service Publication
            SELECT   D."SELECT", D.*, F.*
            FROM   NATIXIS_BS_DICTIONARY D, NATIXIS_BS_FIELDS F
            WHERE   F.SERVICE_ID = 2 AND D.WORD_ID = F.WORD_ID AND F.WORDTYPE <> 2
                and (D."WORD" like '%UNDERLYING_NOM_UNIT%' or D."WORD" like '%UNDERLYING_PRICE_TYPE%') 
            ORDER BY   F.POSITION;
update singlesignon set RISKUSER="MANAGER" where systemuser = 'CIB.NET\XXX' (Soit tu mets MANAGER par défaut dans Riskuser, soit tu ne mets rien et tu pourras choisir via la fenêtre de loggin)
- do not use JOIN TIERS TR ON TR.REFERENCE = VALUE (use LEFT JOIN TIERS)


sqlplus -s CDC2/CDC2@OR_F3_SO @filepath
pipe line
select rownum r from all_objects where rownum < 50
connect by level
SQL functions:
rank, dense_rank, first, last: http://www.oracle-base.com/articles/misc/RankDenseRankFirstLastAnalyticFunctions.php
string aggregation: http://www.oracle-base.com/articles/misc/string-aggregation-techniques.php
devise_to_str, str_to_devise, to_date, last_day, trunc, add_months, to_char, to_number, SQL%ROWCOUNT,
months_between, num_to_date, date_to_num, greatest, least
NVL(E1, E2) <==> IF E1 IS NULL THEN E2 ELSE E1
NVL2(E1, E2, E3) <==> IF E1 IS NULL THEN E3 ELSE E2
decode( expression , search , result [, search , result]... [, default] )
NE JAMAIS utiliser DECODE(expression, null, result)...
select * from USER_ROLE_PRIVS -- pour connaitre les rôles de l'utilisateur
when use "in (select clause)", select clause can not contain null value 
goto l_EndOfLoop;
<<l_EndOfLoop>>
like '%!_%' escape '!' // contains _
  
update from in SQL Server or Sybase
/*******************/
   1: update (select b.bonus as bonus,
   2:                br.min_bonus as new_bonus
   3:           from employee_bonus b
   4:          inner join employees e on b.employee_id = e.employee_id
   5:          inner join bonus_rates br on e.rate_id = br.rate_id
   6:          where e.bonus_eligible = 'Y' ) t
   7: set t.bonus = t.new_bonus
   
if error cannot modify a column which maps to a non key-preserved table
 
   1: update employee_bonus b
   2:    set b.bonus = (select br.min_bonus
   3:                     from employees e
   4:                    inner join bonus_rates br on e.rate_id = br.rate_id
   5:                    where b.employee_id = e.employee_id
   6:                      and e.bonus_eligible = 'Y' )
   7: where exists (select e.employee_id
   8:                 from employees e 
   9:                where b.employee_id = e.employee_id
  10:                  and e.bonus_eligible = 'Y' )

   
update cma_rpt_operations op_main
set (ta, ta_refcon) =
    (select h.montant, h.refcon 
    from cma_rpt_operations op
    join histomvts h on op.mvtident = h.mvtident
        and h.type = decode(op.mvttype , 0, 7, 2, 7, 101)
        and trunc(h.dateneg, 'MM') = op.mois_fact
        and h.backoffice not in ( 13,29,38)
    where op.mvttype != 3
        and op.mois_fact = num_to_date( 39202)
        and op.ctpy_id in (10001086) and op.entity_id = 10003043 and op.fact_cur = 'EUR' and op.fact_freq = 'Mensuel'
        and op.op_id = op_main.op_id
    )
where exists (select op.op_id from cma_rpt_operations op where op.op_id = op_main.op_id)
        and op_main.mois_fact = num_to_date( 39202)
        and op_main.mvttype != 3
        and op_main.ctpy_id in (10001086) and op_main.entity_id = 10003043 and op_main.fact_cur = 'EUR' and op_main.fact_freq = 'Mensuel'

        
update 
    (select op.ta, op.ta_refcon, h.montant, h.refcon
    from cma_rpt_operations op
    join histomvts h on op.mvtident = h.mvtident
        and h.type = decode(op.mvttype , 0, 7, 2, 7, 101)
        and trunc(h.dateneg, 'MM') = op.mois_fact
        and trunc(h.dateneg, 'MM') = num_to_date( 39202)
        and h.backoffice not in ( 13,29,38)
    where op.mvttype != 3
        and op.ctpy_id in (10001086) 
        and op.entity_id = 10003043 
        and op.fact_cur = 'EUR' 
        and op.fact_freq = 'Mensuel') oph
set oph.ta = oph.montant, oph.ta_refcon = oph.refcon

/*******************/ 

select seqlog.nextval from dual;

INSERT INTO security_log
   SELECT seqlog.NEXTVAL, (SELECT ident
                             FROM riskusers
                            WHERE NAME = 'MOE_BO'), SYSDATE, 'DK266798.cib.net',
          1, 101, seqlog.CURRVAL, 0, 0
FROM DUAL;

Billing Generator
begin
    BL.RPT_PRINT_RUN();
end;
BEGIN
    BL.SET_LOG_LEVEL(BL.LOG_DEBUG);
    BL.BILLING_GENERATOR(
        p_source => BL.SRC_FM, -- source FM
        p_date => trunc(to_date('&1', 'YYYYMMDD'), 'MM'),
        p_mvtident => 3297290,
        p_periodicite => 2 -- Mensuel
    );
END;
select EXTRACTVALUE(XMLTYPE(XML), '/Transaction/ACTION') ACTION, X.*, H.ECN, h.* from TS_XML_TBL X
    LEFT JOIN HISTOMVTS H ON ((EXTRACTVALUE(XMLTYPE(XML), '/Transaction/ACTION') IN ('CREATE')
        AND H.INFOSBACKOFFICE = EXTRACTVALUE(XMLTYPE(XML), '/Transaction/ID'))
        OR (EXTRACTVALUE(XMLTYPE(XML), '/Transaction/ACTION') IN ('UPDATE', 'CANCEL')
        AND EXTRACTVALUE(XMLTYPE(XML), '/Transaction/REFCON') = H.REFCON))
where
    System = 'BillingGenerator'
    --system = 'TTF'
    and dateinsert > trunc(sysdate) + 11/24
order by id asc;

select * from all_synonyms where synonym_name='BL';
select * from dba_synonyms where SYNONYM_NAME='BL';
GRANT EXECUTE ON CDC.BL TO RL_EXCEPT
select grantee,granted_role from dba_role_privs where grantee='SHA_SI_EXCEPT_BO'

Use Rownum with Order By:
                SELECT D.D, D.* FROM Dmhistorique D
                WHERE JOUR<TO_DATE('20121121','YYYYMMDD') AND ROWNUM = 1
                    AND SICOVAM = str_to_devise('GBP')
                ORDER BY JOUR DESC;
===> 1.45734 

                SELECT D, D.* FROM Dmhistorique D
                WHERE JOUR<TO_DATE('20121121','YYYYMMDD') AND ROWNUM = 1
                    AND SICOVAM = 55001680
                ORDER BY JOUR DESC;
===> 1.24305853868083

error:
end-of-file on communication channel (ORA-03113: fin de fichier sur canal de communication)
ORA-00600: internal error code, arguments: [kghfrf1], [0x000000000], [], [],
    --> take out the (SELECT VALUE FROM NATIXIS_GROUP_PARAM WHERE TYPE = 'TTF' AND KEY = 'DiscountedMarket_IT')
    into a join table. 

SQUALL:
select trsa.*, trsb.* from trs_basket_adjustment trsa
join trs_basket trsb on trsb.code = trsa.HISTORICID
where trsa.code = 77849914; -- reference of histomvts
select h.reference, h.quantite, h.* from  histomvts h where refcon = 124701522;

Sophis:
position->GetTransactions return all transactions of the position
trans->GetSettlementDate = h.dateval
trans->GetTransactionDate = h.dateneg
trans->GetTransactionType = h.type
trans->GetSpot = h.cours
trans->SetComment = h.infos
trans->GetTransactionCode = refcon
trans->GetPaymentMethod = PAYMENT_METHOD
trans->GetDeliveryType = DELIVERY_TYPE (decode(DELIVERY_TYPE, -1, '*', 1, 'DVP', 2, 'FOP', 3, 'N/A'), eBODeliveryType)
trans->GetSettlementMethod = WORKFLOW_ID
underlying: type == D -->h.codesj, si non -->h.code_emet
instrument->GetMarketCode = t.marche
const CSRTransaction * transaction = CSRTransaction::newCSRTransaction(refcon); // pointer must be deleted after use
const CSRInstrument * instrument = CSRInstrument::GetInstance(sicovam); // pointer must NOT be deleted
CSRCurrency->GetForexHistory --> column D of table historique (DMHistorique or Historique depend on preference) 

CMA:
select * from cma_rpt_operations where op_id in (-1, -2)
select prefvaleur from riskpref where prefnom = 'CMA Updatable status'; = 270
select prefvaleur from riskpref where prefnom = 'CMA Exclude Status';
select id from bo_kernel_events where name = (select prefvaleur from riskpref where prefnom = 'CMAEventToSend'); = 562
select id from bo_kernel_events where name = (select prefvaleur from riskpref where prefnom = 'CMAEventWithoutModif'); = 262
select prefnom from riskpref where prefvaleur = '109'; = G42
select * from riskpref where prefnom in ('G42', 'G43');
select entity_id, ctpy_id, perimeter_id from bo_pe_agreement_main where entity_id = 10003043 and ctpy_id in ( 10021699  )  order by entity_id, ctpy_id, perimeter_id;
select distinct(upper(name)) 	from bo_pe_agreement_main a, tiers t where a.entity_id = t.ident order by upper(name);//entity
select distinct(upper(name))     from bo_pe_agreement_main a, tiers t where a.ctpy_id = t.ident order by upper(name); //contrepartie
select distinct(name) from bo_pe_perimeter_def order by name; //convention AGREEMENT
select distinct(fact_freq) from cma_rpt_operations; //frequency
select distinct(devise_to_str(code)) from devisev2 order by devise_to_str(code) //devise 
select * from titres where reference in ('EURIB_3M', 'EONIA_SL', 'EURIB_6M');
SQL> copy from CDCREAD/CDC05READ@OX_TP_SO to CDC/CDC@OR_TP_SO create bo_tmp_dmhistorique using select * from dmhistorique where sicovam in 
  (select sicovam from titres where reference in ('EURIB_3M','EONIA_SL', 'EURIB_6M')) and jour > trunc(sysdate, 'YY');
End Date = dateval du Maturity Modif (304) (commission_date du Mturity Modify)
Start Date = dateval du Purchase/Sale (1)
min fee = titres.coupon1
rate (comm_rate, commission rate) = cours du Loan/Repo Commission (27), avec quantity > 0
Collat_Value = case when op.mvttype in (1, 2, 3) then round(ex.amount,2) else 0 end Collat_Value
patte principale h1.refcon = patte collateral h2.mirror_reference
Ligne en vert (not executed) --> modifiable
Spread = -1.#IND (à cause de quantite = 0 pour un ticket 28 LOAN/REPO MARGIN)
t.j1refcon2 = ploanAndRepo->GetPaymentType() = Frequency of contract (2= Mensuel, 1 = In Fine)

TicketAuto:
select * from natixis_batches_log where dt > trunc(sysdate) and logger not like '%FX%'
select * from natixis_batches_log where dt > trunc(sysdate) - 4 and LOGGER like '%FA_4UPDATE_2JM_05H5%';
select * from natixis_post_event where dt_demande >= trunc(sysdate) + 12/24 and status = 1;
select count(*) from natixis_post_event where status = 0; // post en cours
sortir les lignes insérés lors de dernier TA:
  select * from histomvts
  where refcon in (
  select refcon from MVT_AUTO_BACKUP
  where trunc(datecre) = trunc(sysdate)
      and origine = 'TA12H'
      and refcon is not null
      and refcon not in (
          select refcon from MVT_AUTO_BACKUP
          where trunc(datecre) = trunc(sysdate) - 1
              and origine = 'TA18H'
              and refcon is not null
      )
  )

settings:
- OTC_WF_DEFINITION_COMPONENT, OTC_WF_DEFINITION_HEAD
select dc.condition1, dh.RECORD_TYPE, dc.*, dh.* from OTC_WF_DEFINITION_COMPONENT dc
join OTC_WF_DEFINITION_HEAD dh on DC.WORKFLOW_ID = DH.ID
where condition1 like '%SSI % REFLET%'
and DH.RECORD_TYPE = 1;
- PBMSG_CONFIG_TEMPLATE
- TIERSSETTLEMENT (tab Settlement Instructions dans Third parties)
- preference
select * from preferences p where P.USER_ID=
( select ident from riskusers where name='EOM_BILLINGSL') and name = 'tablehisto'; (configuré dans End Of Day Configuration)

create customized table:
- declarer table:
    EXEC P_OVERLOADTAB.DECLARATION('dividende_brut');
    commit
- configurer le droit d'accès:
    - menu Manager\Users --> frame Table Acces
- voir si la table est configurée pour un utilisateur:
    - modifier dans .ini
    - se connecter dans sophis, aller dans Menu Parameter\Parameter Set 